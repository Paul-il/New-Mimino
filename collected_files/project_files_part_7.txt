# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\migrations\0071_auto_20240606_1426.py
# Generated by Django 5.0.1 on 2024-06-06 11:26

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('restaurant_app', '0070_alter_message_chat'),
    ]

    operations = [
    ]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\migrations\__init__.py


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\models\message.py
from django.db import models
from django.contrib.auth.models import User

class Chat(models.Model):
    participants = models.ManyToManyField(User, related_name='chats')
    created_at = models.DateTimeField(auto_now_add=True)

    @classmethod
    def get_default_chat(cls):
        default_chat, created = cls.objects.get_or_create(id=1, defaults={})
        return default_chat.id

class Message(models.Model):
    chat = models.ForeignKey(Chat, related_name='messages', on_delete=models.CASCADE)
    sender = models.ForeignKey(User, related_name='sent_messages', on_delete=models.CASCADE)
    body = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)
    read = models.BooleanField(default=False)

    class Meta:
        ordering = ['-timestamp']

    @classmethod
    def unread_count(cls, user):
        return cls.objects.filter(chat__participants=user, read=False).count()


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\models\orders.py
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from .tables import Table
from .product import Product
from django.contrib.auth.models import User
from django.urls import reverse
from django.conf import settings
from django.db.models import Sum, F

class Order(models.Model):
    table = models.ForeignKey(Table, on_delete=models.CASCADE, related_name='orders')
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)
    is_completed = models.BooleanField(default=False)
    comments = models.TextField(null=True, blank=True)
    last_printed_comments = models.TextField(null=True, blank=True)
    table_number = models.IntegerField()
    total_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    num_of_people = models.IntegerField(default=1)
    cash_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    card_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    payment_processed = models.BooleanField(default=False)
    is_confirmed = models.BooleanField(default=False)
    is_bill_printed = models.BooleanField(default=False)

    STATUS_CHOICES = [
        ('active', _('Active')),
        ('completed', _('Completed')),
        ('canceled', _('Canceled')),
    ]
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='active')

    PAYMENT_METHOD_CHOICES = [
        ('cash', _('Cash')),
        ('card', _('Card')),
        ('mixed', _('Mixed')),
    ]
    payment_method = models.CharField(max_length=10, choices=PAYMENT_METHOD_CHOICES, null=True, blank=True)

    def total_sum(self):
        """Calculate the total sum of the order."""
        return self.order_items.aggregate(total=Sum(F('product__product_price') * F('quantity')))['total']

    def get_total_amount(self):
        """Alias for total_sum method to avoid changing existing code."""
        return self.total_sum()

    def remaining_amount(self):
        """Calculate the remaining amount to be paid."""
        total_paid = self.cash_amount + self.card_amount
        return self.total_sum() - total_paid

    def __str__(self):
        return f"Order {self.pk} ({self.table})"

    def tips_provided(self):
        """Check if tips have been provided."""
        return self.tips.exists()

    def get_absolute_url(self):
        return reverse('cart_detail', args=[str(self.id)])


class WaiterOrder(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='waiter_orders')
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='created_waiter_orders')
    last_printed_comments = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    is_completed = models.BooleanField(default=False)


class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='order_items', null=True, blank=True)
    waiter_order = models.ForeignKey('WaiterOrder', on_delete=models.CASCADE, related_name='waiter_order_items', null=True, blank=True)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='order_items')
    quantity = models.PositiveIntegerField(_('quantity'), default=1)
    phone_number = models.CharField(max_length=10)
    printed = models.BooleanField(default=False)
    printed_quantity = models.IntegerField(default=0)
    discount_percentage = models.DecimalField(max_digits=5, decimal_places=2, default=0.00, verbose_name='Процент скидки')
    is_delivered = models.BooleanField(default=False)

    class Meta:
        unique_together = ('order', 'product')

    @classmethod
    def remove_zero_quantity_products(cls):
        """Remove products with zero quantity."""
        cls.objects.filter(quantity=0).delete()

    def save(self, *args, **kwargs):
        is_new = self.pk is None

        if is_new:  # Новый объект
            if self.product.has_limit:
                if self.product.limit_quantity >= self.quantity:
                    self.product.limit_quantity = max(0, self.product.limit_quantity - self.quantity)
                    if self.product.limit_quantity == 0:
                        self.product.is_available = False
                    self.product.save()
                else:
                    raise ValueError('Not enough quantity available in the limit')
        else:
            old_quantity = OrderItem.objects.get(pk=self.pk).quantity
            quantity_difference = self.quantity - old_quantity
            if self.product.has_limit:
                if self.product.limit_quantity + old_quantity >= self.quantity:
                    self.product.limit_quantity = max(0, self.product.limit_quantity - quantity_difference)
                    if self.product.limit_quantity == 0:
                        self.product.is_available = False
                    self.product.save()
                else:
                    raise ValueError('Not enough quantity available in the limit')
        super().save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        if not self.is_delivered and self.product.has_limit:
            self.product.limit_quantity += self.quantity
            if self.product.limit_quantity > 0:
                self.product.is_available = True
            self.product.save()
        super().delete(*args, **kwargs)

    def mark_delivered(self):
        self.is_delivered = True
        self.save()

    def unmark_delivered(self):
        self.is_delivered = False
        self.save()


class Category(models.Model):
    name = models.CharField(max_length=200)
    
    def __str__(self):
        return self.name


class PaymentMethod(models.Model):
    CASH = 'CASH'
    BANK_TRANSFER = 'BANK'
    CREDIT_CARD = 'CARD'
    MIXED = 'MIXED'
    PAYMENT_METHOD_CHOICES = [
        (CASH, 'Cash'),
        (BANK_TRANSFER, 'Bank Transfer'),
        (CREDIT_CARD, 'Card'),
        (MIXED, 'Mixed')
    ]
    
    method = models.CharField(max_length=5, choices=PAYMENT_METHOD_CHOICES)
    
    def __str__(self):
        return self.get_method_display()


class Transaction(models.Model):
    INCOME = 'IN'
    EXPENSE = 'EX'
    TRANSACTION_TYPE_CHOICES = [
        (INCOME, 'Income'),
        (EXPENSE, 'Expense'),
    ]

    type = models.CharField(max_length=2, choices=TRANSACTION_TYPE_CHOICES)
    category = models.ForeignKey(Category, on_delete=models.CASCADE)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    added_date = models.DateField(auto_now_add=True)
    date = models.DateField()
    payment_method = models.ForeignKey(PaymentMethod, on_delete=models.SET_NULL, null=True, blank=True)
    cash_amount = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    card_amount = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)

    def __str__(self):
        return str(self.category.name)
    

def get_payment_method_from_order(order):
    """Get the payment method for a given order."""
    payment_methods = {
        Order.PaymentMethod.CASH: 'Cash',
        Order.PaymentMethod.CARD: 'Card',
        Order.PaymentMethod.MIXED: 'Mixed'
    }
    return payment_methods.get(order.payment_method)


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\models\product.py
from django.db import models
from django import forms
from django.contrib.auth.models import User
from django.conf import settings

class Product(models.Model):
    CATEGORY_CHOICES = [
        ('first_dishes', 'first_dishes'),
        ('meat_dishes', 'meat_dishes'),
        ('bakery', 'bakery'),
        ('khinkali', 'khinkali'),
        ('khachapuri', 'khachapuri'),
        ('garnish', 'garnish'),
        ('grill_meat', 'grill_meat'),
        ('dessert', 'dessert'),
        ('soups', 'soups'),
        ('salads', 'salads'),
        ('sales', 'sales'),
        ('delivery', 'delivery'),
        ('drinks', 'drinks'),
        ('soft_drinks', 'soft_drinks'),
        ('beer', 'beer'),
        ('wine', 'wine'),
        ('vodka', 'vodka'),
        ('cognac', 'cognac'),
        ('whisky', 'whisky'),
        ('dessert_drinks', 'dessert_drinks'),
        ('own_alc', 'own_alc'),
        ('banket', 'banket'),
        ('mishloha', 'mishloha'),
    ]

    PRINTER_CHOICES = [
        ('print80', 'Бар'),
        ('Printer80', 'Мал Кухня'),
        ('Printer80-2', 'Бол Кухня'),
    ]

    id = models.AutoField(primary_key=True)
    product_name_rus = models.CharField(max_length=100, verbose_name='Название блюда (рус.)')
    product_name_heb = models.CharField(max_length=100, verbose_name='שם מנה (עברית)')
    product_price = models.DecimalField(max_digits=6, decimal_places=2, verbose_name='Цена продукта')
    product_img = models.ImageField(upload_to='product_images/', blank=True, null=True)
    category = models.CharField(max_length=50, choices=CATEGORY_CHOICES)
    printer = models.CharField(max_length=50, choices=PRINTER_CHOICES, default='print80', verbose_name='Принтер')
    created_at = models.DateTimeField(auto_now_add=True)
    quantity = models.PositiveIntegerField(default=1)
    delivery_price = models.DecimalField(max_digits=8, decimal_places=2, null=True, blank=True)
    is_available = models.BooleanField(default=True)
    preparation_time = models.PositiveIntegerField(default=0, verbose_name='Время приготовления (в минутах)', blank=True)
    has_limit = models.BooleanField(default=False, verbose_name='Лимитированный продукт')
    limit_quantity = models.PositiveIntegerField(null=True, blank=True, verbose_name='Количество лимита')

    def __str__(self):
        return f"{self.product_name_rus} ({self.product_price}₪)"


class ProductQuantityForm(forms.ModelForm):
    class Meta:
        model = Product
        fields = ['quantity']


class OrderChangeLog(models.Model):
    ACTION_CHOICES = (
        ('add', 'Добавили'),
        ('decrease', 'Убавили'),
        ('delete', 'Удалили'),
        ('increase', 'Прибавили'),
    )

    order = models.ForeignKey('Order', on_delete=models.CASCADE)
    order_item = models.ForeignKey('OrderItem', on_delete=models.CASCADE, null=True, blank=True)
    product_name = models.CharField(max_length=255)
    action = models.CharField(max_length=10, choices=ACTION_CHOICES)
    change_time = models.DateTimeField(auto_now_add=True)
    changed_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, verbose_name='Изменил')

    class Meta:
        ordering = ['change_time']


class ProductStock(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='stock')
    received_quantity = models.PositiveIntegerField()
    received_date = models.DateField(auto_now_add=True)

    def __str__(self):
        return f"{self.product.product_name_rus} - {self.received_quantity} received on {self.received_date}"


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\models\tables.py
from django.db import models
from django.contrib.auth.models import User
from django import forms


class Room(models.Model):
    name = models.CharField(max_length=255)
    max_capacity = models.IntegerField(null=True, blank=True)

    def __str__(self):
        return self.name


class Table(models.Model):
    table_id = models.IntegerField()
    room = models.ForeignKey(Room, on_delete=models.CASCADE, related_name='tables', null=True, blank=True)
    description = models.TextField(null=True, blank=True)
    is_booked = models.BooleanField(default=False)
    is_ordered = models.BooleanField(default=False)
    reserved_date = models.DateField(null=True, blank=True)
    reserved_time = models.TimeField(null=True, blank=True)
    num_of_people = models.IntegerField(null=True, blank=True)
    order_time = models.DateTimeField(null=True, blank=True)
    are_guests_here = models.BooleanField(default=False)
    capacity = models.IntegerField()
    active_order = models.BooleanField(default=False)
    is_available = models.BooleanField(default=True)  # Новый атрибут

    def get_active_order(self):
        from .orders import Order  # Импортируем модель Order внутри метода, чтобы избежать цикличного импорта
        return Order.objects.filter(table=self, is_completed=False).last()

    def __str__(self):
        return f'Table {self.table_id}'

    def orders(self):
        from .orders import Order
        return Order.objects.filter(table=self)

    class Meta:
        ordering = ['table_id']


class Booking(models.Model):
    table = models.ForeignKey(Table, on_delete=models.CASCADE, related_name='bookings')
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='bookings')
    reserved_date = models.DateField()
    reserved_time = models.TimeField()
    num_of_people = models.IntegerField()
    are_guests_here = models.BooleanField(default=False)
    description = models.TextField(blank=True, null=True)
    is_deleted = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    guests_did_not_arrive = models.BooleanField(default=False)

    def __str__(self):
        return f"Бронирование {self.id} - стол {self.table.table_id} ({self.reserved_date} {self.reserved_time} {self.user.first_name})"


class GuestsHereForm(forms.ModelForm):
    class Meta:
        model = Booking
        fields = ['are_guests_here']
        widgets = {'are_guests_here': forms.HiddenInput()}


class Tip(models.Model):
    amount = models.DecimalField(max_digits=6, decimal_places=2)
    date = models.DateTimeField(auto_now_add=True, db_index=True)  # Добавление индекса
    order = models.ForeignKey('Order', on_delete=models.CASCADE, related_name='tips', null=True, blank=True)

    def __str__(self):
        return f"Total tip: {self.amount} on {self.date}"


class TipDistribution(models.Model):
    tip = models.ForeignKey(Tip, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    amount = models.DecimalField(max_digits=6, decimal_places=2)

    class Meta:
        unique_together = (('tip', 'user'),)
        indexes = [
            models.Index(fields=['user', 'amount'])  # Добавление индекса
        ]

    def __str__(self):
        return f"{self.user.username} получает {self.amount} чаевых от чаевых {self.tip.id}"


class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='userprofile')
    tips = models.FloatField(default=0)


class TipGoal(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='tipgoal')
    goal = models.FloatField(default=0)


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\models\__init__.py


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\tables\tasks.py
from datetime import datetime, timedelta
from celery import shared_task
from ..models import Table


@shared_task
def check_reserved_tables():
    # Получаем все забронированные столики, у которых время брони прошло
    reserved_tables = Table.objects.filter(is_booked=True, reserved_datetime__lt=datetime.now())

    for table in reserved_tables:
        # Если время брони прошло более чем на 30 минут и гости еще не пришли, освобождаем столик
        if datetime.now() - table.reserved_datetime > timedelta(minutes=30) and not table.are_guests_here:
            table.is_booked = False
            table.save()


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\templatetags\custom_tags.py
from django import template

from restaurant_app.models.product import Product


register = template.Library()

@register.filter
def get_item(dictionary, key):
    return dictionary.get(key)

@register.filter(name='append_grams')
def append_grams(value, arg):
    if arg in ["Замороженные Пельмени", "Замороженные Хинкали"]:
        return f"{value} гр"
    return value

@register.filter
def get_product_name_heb(product_id):
    return Product.objects.get(id=product_id).product_name_heb

@register.filter
def get_product_name_rus(product_id):
    return Product.objects.get(id=product_id).product_name_rus

@register.filter
def total_price(order):
    return sum(item.product.product_price * item.quantity for item in order.order_items.all())

@register.filter
def pickup_total_price(cart):
    return sum(item.quantity * item.product.product_price for item in cart.cart_items.all())


@register.filter
def delivery_total_price(cart):
    return sum(item.quantity * item.product.product_price for item in cart.delivery_cart_items.all())

@register.filter
def split(value, arg):
    return value.split(arg)

@register.filter
def index(List, i):
    return List[int(i) - 1]

@register.filter
def translate_weekday(value):
    day_names = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    russian_day_names = ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"]
    day_mapping = dict(zip(day_names, russian_day_names))
    return day_mapping.get(value, '')

@register.filter
def get_weekday_name(value):
    day_names = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    try:
        return day_names[value - 2]
    except IndexError:
        return ""

@register.filter
def get_item(dictionary, key):
    return dictionary.get(key)

# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\views_folder\add_stock_view.py
import logging
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.conf import settings
from ..models.product import Product, ProductStock
from ..forms import CategorySelectForm

# Configure logger
logger = logging.getLogger(__name__)

LOW_STOCK_THRESHOLD = 3

@login_required
def limited_products_view(request):
    categories = dict(Product.CATEGORY_CHOICES)
    selected_category = request.GET.get('category', '')
    
    if selected_category:
        products = Product.objects.filter(category=selected_category, has_limit=True)
    else:
        products = Product.objects.filter(has_limit=True, limit_quantity__lt=10)
    
    low_stock_products = products.filter(limit_quantity__lte=LOW_STOCK_THRESHOLD)
    for product in low_stock_products:
        messages.warning(request, f'Внимание: количество продукта "{product.product_name_rus}" ниже порогового уровня.')

    form = CategorySelectForm(initial={'category': selected_category})

    return render(request, 'limited_products.html', {
        'form': form,
        'products': products,
        'categories': categories,
    })

@login_required
def update_product_stock(request, product_id):
    product = get_object_or_404(Product, id=product_id, has_limit=True)
    if request.method == 'POST':
        received_quantity = int(request.POST.get('received_quantity', 0))
        if received_quantity > 0:
            ProductStock.objects.create(product=product, received_quantity=received_quantity)
            product.limit_quantity += received_quantity
            product.save()
            messages.success(request, f'Количество продукта {product.product_name_rus} обновлено на {received_quantity}.')
        else:
            messages.error(request, 'Количество должно быть больше нуля.')
    return redirect('limited_products')


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\views_folder\ask_where_views.py
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required

@login_required
def ask_where_view(request):
    if request.user.is_authenticated:
        return render(request, 'ask_where.html')
    else:
        return redirect('login')

# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\views_folder\book_table_view.py
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.urls import reverse
from django.db import transaction
from django.core.exceptions import ValidationError
from ..models.orders import Order,OrderItem
from ..models.tables import Booking
from ..forms import BookingForm


@login_required
def edit_booking_view(request, booking_id):
    booking = get_object_or_404(Booking, id=booking_id)

    if request.method == 'POST':
        form = BookingForm(request.POST, instance=booking)
        if form.is_valid():
            form.save()
            messages.success(request, 'Бронирование успешно обновлено.')
            return redirect('bookings')
    else:
        form = BookingForm(instance=booking)

    return render(request, 'edit_booking.html', {'form': form, 'booking_id': booking_id})


@login_required
def book_table_view(request):
    if request.method == 'POST':
        form = BookingForm(request.POST, request=request)
        if form.is_valid():
            try:
                with transaction.atomic():
                    booking = create_booking_and_order(request, form)
                messages.success(request, 'Стол успешно забронирован.')
                return redirect('bookings')
            except Exception as e:
                messages.error(request, f'Ошибка при бронировании стола: {e}')

    else:
        form = BookingForm(request=request)

    return render(request, 'restaurant_app/book_table.html', {'form': form})


@login_required
def create_booking_and_order(request, form):
    booking = form.save(commit=False)
    booking.user = request.user
    booking.table = form.cleaned_data['table']  # Получение выбранного стола из очищенных данных
    booking.save()

    order = Order.objects.create(
        table=booking.table,
        created_by=request.user,
        is_completed=False,
    )

    banket_products = booking.get_banket_products()
    for product in banket_products:
        OrderItem.objects.create(
            order=order,
            product=product,
            quantity=1
        )
    return booking


@login_required
def guests_not_arrived_view(request, booking_id):
    if request.method == "POST":
        # Получаем объект бронирования по переданному ID
        booking = get_object_or_404(Booking, id=booking_id)

        # Получаем комментарий из запроса, если он был предоставлен
        comment = request.POST.get('comment', '').strip()
        if comment:
            booking.description = comment

        # Отмечаем, что гости не пришли
        booking.guests_did_not_arrive = True
        
        # Отмечаем бронирование как "удаленное" (но фактически не удаляем из базы данных)
        booking.is_deleted = True

        booking.save()

        # Сообщаем пользователю, что бронирование было обновлено
        messages.success(request, 'Бронирование обновлено.')

        return redirect('bookings')


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\restaurant_app\views_folder\cabinet.py
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth import update_session_auth_hash
from django.contrib.auth.forms import PasswordChangeForm


from django.contrib import messages


@login_required
def personal_cabinet(request):
    return render(request, 'personal_cabinet.html')

@login_required
def change_password(request):
    if request.method == 'POST':
        form = PasswordChangeForm(request.user, request.POST)
        if form.is_valid():
            user = form.save()
            update_session_auth_hash(request, user)  # Сохраняем сессию пользователя
            messages.success(request, 'Ваш пароль был успешно изменен!')
            return redirect('personal_cabinet')
        else:
            messages.error(request, 'Пожалуйста, исправьте ошибки ниже.')
    else:
        form = PasswordChangeForm(request.user)
        form.fields['old_password'].label = 'Старый пароль'
        form.fields['new_password1'].label = 'Новый пароль'
        form.fields['new_password2'].label = 'Подтверждение нового пароля'
        
        # Заменяем сообщения об ошибках на русском языке
        form.error_messages['password_mismatch'] = 'Введенные пароли не совпадают.'
        form.fields['new_password1'].error_messages = {
            'password_too_similar': 'Ваш пароль не должен быть слишком похож на другую вашу личную информацию.',
            'password_too_short': 'Ваш пароль должен содержать не менее 8 символов.',
            'password_too_common': 'Ваш пароль не должен быть распространённым паролем.',
            'password_entirely_numeric': 'Ваш пароль не должен состоять только из цифр.'
        }

    return render(request, 'change_password.html', {'form': form})

@login_required
def edit_profile(request):
    if request.method == 'POST':
        user = request.user
        user.first_name = request.POST['first_name']
        user.last_name = request.POST['last_name']
        user.email = request.POST['email']
        user.save()
        messages.success(request, 'Ваш профиль был успешно обновлен!')
        return redirect('personal_cabinet')
    return render(request, 'edit_profile.html', {'user': request.user})




# End of file

