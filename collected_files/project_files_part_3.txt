# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\expenses\migrations\0001_initial.py
# Generated by Django 4.2.1 on 2023-11-05 17:42

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Category',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=200)),
            ],
        ),
        migrations.CreateModel(
            name='PaymentMethod',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('method', models.CharField(choices=[('CASH', 'Cash'), ('BANK', 'Bank Transfer'), ('CARD', 'Credit Card')], max_length=4)),
            ],
        ),
        migrations.CreateModel(
            name='Transaction',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('type', models.CharField(choices=[('IN', 'Income'), ('EX', 'Expense')], max_length=2)),
                ('amount', models.DecimalField(decimal_places=2, max_digits=10)),
                ('added_date', models.DateField(auto_now_add=True)),
                ('date', models.DateField()),
                ('category', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='expenses.category')),
                ('payment_method', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='expenses.paymentmethod')),
            ],
        ),
    ]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\expenses\migrations\0002_rename_paymentmethod_paymethod.py
# Generated by Django 4.2.1 on 2023-11-14 20:43

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('expenses', '0001_initial'),
    ]

    operations = [
        migrations.RenameModel(
            old_name='PaymentMethod',
            new_name='PayMethod',
        ),
    ]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\expenses\migrations\0003_remove_transaction_category_and_more.py
# Generated by Django 4.2.1 on 2023-11-15 20:52

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('expenses', '0002_rename_paymentmethod_paymethod'),
    ]

    operations = [
        migrations.RemoveField(
            model_name='transaction',
            name='category',
        ),
        migrations.RemoveField(
            model_name='transaction',
            name='payment_method',
        ),
        migrations.DeleteModel(
            name='Category',
        ),
        migrations.DeleteModel(
            name='PayMethod',
        ),
        migrations.DeleteModel(
            name='Transaction',
        ),
    ]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\expenses\migrations\__init__.py


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\expenses\view\transactions.py
from django.db.models import Sum, Case, When, Value, IntegerField
from django.db import models
from datetime import date, datetime, timezone
from django.utils import timezone

from django.db.models.signals import post_save
from django.dispatch import receiver
from restaurant_app.models.orders import Order, Category

from restaurant_app.models.orders import Transaction, PaymentMethod 

from django.shortcuts import render
from restaurant_app.views_folder.order_summary import get_summary_data
from pickup_app.models import PickupOrder
from delivery_app.models import DeliveryOrder

def get_summary_data_from_order_summary(start_date, end_date):
    # Если даты не предоставлены, используем текущую дату
    start_datetime = start_date if start_date else timezone.localdate()
    end_datetime = end_date if end_date else timezone.localdate()

    # Фильтрация заказов на доставку и самовывоз по датам
    total_delivery_income = DeliveryOrder.objects.filter(
        delivery_date__range=(start_datetime, end_datetime)
    ).aggregate(total=Sum('total_amount'))['total'] or 0

    total_pickup_income = PickupOrder.objects.filter(
        date_created__range=(start_datetime, end_datetime)
    ).aggregate(total=Sum('total_amount'))['total'] or 0

    return total_delivery_income, total_pickup_income


@receiver(post_save, sender=DeliveryOrder)
def create_transaction_on_delivery_completion(sender, instance, **kwargs):
    # Проверяем, что заказ завершен и дата доставки совпадает с текущей датой
    if instance.is_completed and instance.delivery_date == timezone.localdate():
        category, _ = Category.objects.get_or_create(name='Delivery Income')

        # Определение метода платежа и суммы
        payment_method = None
        cash_amount = None
        card_amount = None

        if instance.payment_method == 'cash':
            payment_method = PaymentMethod.objects.filter(method=PaymentMethod.CASH).first()
            cash_amount = instance.total_amount
        elif instance.payment_method == 'credit_card':
            payment_method = PaymentMethod.objects.filter(method=PaymentMethod.CREDIT_CARD).first()
            card_amount = instance.total_amount

        # Создание транзакции
        Transaction.objects.create(
            type=Transaction.INCOME,
            category=category,
            amount=instance.total_amount,
            cash_amount=cash_amount,
            card_amount=card_amount,
            payment_method=payment_method,
            date=instance.delivery_date  # Дата доставки из экземпляра
        )


@receiver(post_save, sender=PickupOrder)
def create_transaction_on_pickup_completion(sender, instance, **kwargs):
    if instance.is_completed:
        category, _ = Category.objects.get_or_create(name='Pickup Income')
        
        # Определение метода платежа и суммы
        payment_method = None
        cash_amount = None
        card_amount = None

        if instance.payment_method == 'cash':
            payment_method = PaymentMethod.objects.filter(method=PaymentMethod.CASH).first()
            cash_amount = instance.total_amount
        elif instance.payment_method == 'card':
            payment_method = PaymentMethod.objects.filter(method=PaymentMethod.CREDIT_CARD).first()
            card_amount = instance.total_amount

        # Создаем транзакцию
        Transaction.objects.create(
            type=Transaction.INCOME,
            category=category,
            amount=instance.total_amount,
            cash_amount=cash_amount,
            card_amount=card_amount,
            payment_method=payment_method,
            date=instance.created_at
        )



@receiver(post_save, sender=Order)
def create_transaction_on_order_completion(sender, instance, **kwargs):
    if instance.is_completed and instance.payment_processed:
        # Используем новую категорию 'Table Service Income' вместо 'Order Income'
        category, _ = Category.objects.get_or_create(name='Table Service Income')

        # Определяем метод платежа
        payment_method = None
        cash_amount = None
        card_amount = None

        if instance.payment_method == Order.PaymentMethod.CASH:
            payment_method = PaymentMethod.objects.filter(method=PaymentMethod.CASH).first()
            cash_amount = instance.total_sum()
        elif instance.payment_method == Order.PaymentMethod.CARD:
            payment_method = PaymentMethod.objects.filter(method=PaymentMethod.CREDIT_CARD).first()
            card_amount = instance.total_sum()
        elif instance.payment_method == Order.PaymentMethod.MIXED:
            payment_method = PaymentMethod.objects.filter(method=PaymentMethod.MIXED).first()
            cash_amount = instance.cash_amount
            card_amount = instance.card_amount

        # Создаем транзакцию с новой категорией
        transaction = Transaction.objects.create(
            type=Transaction.INCOME,
            category=category,
            amount=instance.total_sum(),
            cash_amount=cash_amount,
            card_amount=card_amount,
            payment_method=payment_method,
            date=instance.updated_at
        )

        # Опционально: логирование для отладки
        payment_method_name = payment_method.get_method_display() if payment_method else "Не определен"
        


def transaction_list(request):
    start_date = request.GET.get('start_date')
    end_date = request.GET.get('end_date')

    incomes_query = Transaction.objects.filter(type=Transaction.INCOME)
    expenses_query = Transaction.objects.filter(type=Transaction.EXPENSE)

    start_datetime = timezone.localdate()
    end_datetime = timezone.localdate()
    # Преобразование дат из строки в объект datetime
    if start_date:
        start_datetime = datetime.strptime(start_date, '%Y-%m-%d').date()
        start_datetime_aware = timezone.make_aware(datetime.combine(start_datetime, datetime.min.time()))
    else:
        start_datetime_aware = timezone.make_aware(datetime.combine(timezone.localdate(), datetime.min.time()))

    if end_date:
        end_datetime = datetime.strptime(end_date, '%Y-%m-%d').date()
        end_datetime_aware = timezone.make_aware(datetime.combine(end_datetime, datetime.max.time()))
    else:
        end_datetime_aware = timezone.make_aware(datetime.combine(timezone.localdate(), datetime.max.time()))

    # Получение данных о доходах от доставки и самовывоза
    total_delivery_income, total_pickup_income = get_summary_data_from_order_summary(start_datetime, end_datetime)

    if start_date and end_date:
        incomes = incomes_query.filter(date__range=(start_date, end_date))
        expenses = expenses_query.filter(date__range=(start_date, end_date))
    else:
        incomes = incomes_query.all()
        expenses = expenses_query.all()
    
    # Используем агрегацию для суммирования
    total_income = incomes.aggregate(total=models.Sum('amount'))['total'] or 0
    total_expense = expenses.aggregate(total=models.Sum('amount'))['total'] or 0

    difference = total_income - total_expense
    percentage_difference = ((total_income - total_expense) / total_expense) * 100 if total_expense else 100

    category_expenses = expenses.values('category__name').annotate(total=models.Sum('amount'))
    category_names = [item['category__name'] for item in category_expenses]
    category_amounts = [float(item['total']) for item in category_expenses]

    total_amount = sum(category_amounts)
    category_percentages = [(amount / total_amount) * 100 for amount in category_amounts]
    category_names_with_percentages = [f"{name} ({percentage:.2f}%)" for name, percentage in zip(category_names, category_percentages)]

    cash_method = PaymentMethod.objects.filter(method=PaymentMethod.CASH).first()
    card_method = PaymentMethod.objects.filter(method=PaymentMethod.CREDIT_CARD).first()
    bank_transfer_method = PaymentMethod.objects.filter(method=PaymentMethod.BANK_TRANSFER).first()

    cash_amount = expenses.filter(payment_method=cash_method).aggregate(total=models.Sum('amount'))['total'] or 0 if cash_method else 0
    card_amount = expenses.filter(payment_method=card_method).aggregate(total=models.Sum('amount'))['total'] or 0 if card_method else 0
    bank_transfer_amount = expenses.filter(payment_method=bank_transfer_method).aggregate(total=models.Sum('amount'))['total'] or 0 if bank_transfer_method else 0

    # Агрегация для сумм наличных и карты
    total_cash_income = incomes.filter(models.Q(payment_method__method='CASH') | models.Q(payment_method__method='MIXED')).aggregate(total=models.Sum('cash_amount'))['total'] or 0
    total_card_income = incomes.filter(models.Q(payment_method__method='CARD') | models.Q(payment_method__method='MIXED')).aggregate(total=models.Sum('card_amount'))['total'] or 0


    bank_transfer_income = incomes.filter(payment_method=bank_transfer_method).aggregate(total=models.Sum('amount'))['total'] or 0 if bank_transfer_method else 0

    cash_method = PaymentMethod.objects.filter(method=PaymentMethod.CASH).first()
    card_method = PaymentMethod.objects.filter(method=PaymentMethod.CREDIT_CARD).first()
    mixed_method = PaymentMethod.objects.filter(method=PaymentMethod.MIXED).first()

    total_cash_income = incomes.annotate(
        cash_income=Case(
            When(payment_method=cash_method, then='amount'),
            When(payment_method=mixed_method, then='cash_amount'),
            default=Value(0),
            output_field=IntegerField()
        )
    ).aggregate(total=Sum('cash_income'))['total'] or 0

    # Агрегация для карты
    total_card_income = incomes.annotate(
        card_income=Case(
            When(payment_method=card_method, then='amount'),
            When(payment_method=mixed_method, then='card_amount'),
            default=Value(0),
            output_field=IntegerField()
        )
    ).aggregate(total=Sum('card_income'))['total'] or 0

    delivery_income_cash = 0
    delivery_income_card = 1

    selected_date = request.GET.get('selected_date')

    if selected_date:
        selected_datetime = datetime.strptime(selected_date, '%Y-%m-%d').date()
        selected_datetime_aware = timezone.make_aware(datetime.combine(selected_datetime, datetime.min.time()))

        # Пример запроса для расчета дохода от доставки с разбивкой по методам оплаты
        delivery_income_cash = DeliveryOrder.objects.filter(
            delivery_date__range=(start_datetime, end_datetime), 
            payment_method='cash'
        ).aggregate(total=Sum('total_amount'))['total'] or 0

        delivery_income_card = DeliveryOrder.objects.filter(
            delivery_date__range=(start_datetime, end_datetime), 
            payment_method='credit_card'
        ).aggregate(total=Sum('total_amount'))['total'] or 0


    else:
        # Фильтрация заказов на доставку и самовывоз по датам
        total_delivery_income = DeliveryOrder.objects.filter(
            delivery_date__range=(start_datetime, end_datetime)
        ).aggregate(total=Sum('total_amount'))['total'] or 0

        total_pickup_income = PickupOrder.objects.filter(
            date_created__range=(start_datetime, end_datetime)
        ).aggregate(total=Sum('total_amount'))['total'] or 0

    # Использование осведомленных дат в запросах
    pickup_income_cash = PickupOrder.objects.filter(
        date_created__range=(start_datetime_aware, end_datetime_aware), 
        payment_method='cash'
    ).aggregate(total=Sum('total_amount'))['total'] or 0

    pickup_income_card = PickupOrder.objects.filter(
        date_created__range=(start_datetime_aware, end_datetime_aware), 
        payment_method='card'
    ).aggregate(total=Sum('total_amount'))['total'] or 0

    table_service_income = Transaction.objects.filter(
    type=Transaction.INCOME, 
    category__name='Table Service Income', 
    date__range=(start_datetime_aware, end_datetime_aware)
    ).aggregate(total=Sum('amount'))['total'] or 0

    table_service_income_cash = Transaction.objects.filter(
    type=Transaction.INCOME, 
    category__name='Table Service Income', 
    date__range=(start_datetime_aware, end_datetime_aware),
    payment_method__method=PaymentMethod.CASH
    ).aggregate(total=Sum('cash_amount'))['total'] or 0

    table_service_income_card = Transaction.objects.filter(
        type=Transaction.INCOME, 
        category__name='Table Service Income', 
        date__range=(start_datetime_aware, end_datetime_aware),
        payment_method__method=PaymentMethod.CREDIT_CARD
    ).aggregate(total=Sum('card_amount'))['total'] or 0


    payment_methods_stats = [
        {'payment_method': 'Наличные', 'total': cash_amount},
        {'payment_method': 'Карта', 'total': card_amount},
        {'payment_method': 'Банковский перевод', 'total': bank_transfer_amount},
    ]

    payment_methods_income_stats = [
        {'payment_method': 'Наличные', 'total': total_cash_income},
        {'payment_method': 'Карта', 'total': total_card_income},
        {'payment_method': 'Банковский перевод', 'total': bank_transfer_income},
    ]
    # Прибавляем доходы от доставки и самовывоза к общему доходу
    
    return render(request, 'transaction_list.html', {
        'incomes': incomes,
        'expenses': expenses,
        'total_income': total_income,
        'total_expense': total_expense,
        'total_delivery_income': total_delivery_income,
        'total_delivery_income_cash': delivery_income_cash,
        'total_delivery_income_card': delivery_income_card,
        'total_pickup_income_cash': pickup_income_cash,
        'total_pickup_income_card': pickup_income_card,
        'total_pickup_income': total_pickup_income,
        'total_table_service_income_cash': table_service_income_cash,
        'total_table_service_income_card': table_service_income_card,
        'total_table_service_income': table_service_income,
        'difference': difference,
        'percentage_difference': percentage_difference,
        'category_names': category_names,
        'category_amounts': category_amounts,
        'category_percentages': category_percentages,
        'category_names_with_percentages': category_names_with_percentages,
        'payment_methods_stats': payment_methods_stats,
        'payment_methods_income_stats': payment_methods_income_stats,
        'start_date': start_date or '',
        'end_date': end_date or '',
    })

# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\order_statistics\admin.py


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\order_statistics\apps.py
from django.apps import AppConfig


class OrderStatisticsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'order_statistics'


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\order_statistics\models.py
from django.db import models
from django.utils import timezone
from restaurant_app.models.tables import Table
from restaurant_app.models.product import Product
from django.contrib.auth.models import User

class StatisticsOrder(models.Model):
    table = models.ForeignKey(Table, on_delete=models.CASCADE, related_name='statistics_orders')
    created_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='statistics_orders')
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)
    is_completed = models.BooleanField(default=False)
    comments = models.TextField(null=True, blank=True)
    last_printed_comments = models.TextField(null=True, blank=True)
    table_number = models.IntegerField()
    total_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    status = models.CharField(max_length=20)
    payment_method = models.CharField(max_length=10, null=True, blank=True)

    class Meta:
        managed = False
        db_table = 'restaurant_app_order'

class StatisticsOrderItem(models.Model):
    order = models.ForeignKey(StatisticsOrder, on_delete=models.CASCADE, related_name='statistics_order_items')
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='statistics_order_items')
    quantity = models.PositiveIntegerField(default=1)
    phone_number = models.CharField(max_length=10)
    printed = models.BooleanField(default=False)
    printed_quantity = models.IntegerField(default=0)

    class Meta:
        managed = False
        db_table = 'restaurant_app_orderitem'
    
    def __str__(self):
        return f"OrderItem {self.pk} ({self.product})" 
    

# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\order_statistics\statistics.py
from django.db.models import Count
from django.db import models
from .models import StatisticsOrder

def get_daily_orders():
    return StatisticsOrder.objects.annotate(date=models.functions.TruncDate('created_at')).values('date').annotate(order_count=Count('id')).order_by('date')


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\order_statistics\tests.py
from django.test import TestCase

# Create your tests here.


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\order_statistics\urls.py
from django.urls import path
from .views import daily_orders

app_name = 'order_statistics'

urlpatterns = [
    path('daily-orders/', daily_orders, name='daily-orders'),
]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\order_statistics\views.py
from django.http import JsonResponse
from .models import get_daily_orders

def daily_orders(request):
    data = get_daily_orders()
    return JsonResponse(list(data), safe=False)


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\order_statistics\__init__.py


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\order_statistics\migrations\0001_initial.py
# Generated by Django 4.2.1 on 2023-07-07 15:06

from django.db import migrations, models
import django.utils.timezone


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='StatisticsOrder',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(default=django.utils.timezone.now)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('is_completed', models.BooleanField(default=False)),
                ('comments', models.TextField(blank=True, null=True)),
                ('last_printed_comments', models.TextField(blank=True, null=True)),
                ('table_number', models.IntegerField()),
                ('total_price', models.DecimalField(blank=True, decimal_places=2, max_digits=10, null=True)),
                ('status', models.CharField(max_length=20)),
                ('payment_method', models.CharField(blank=True, max_length=10, null=True)),
            ],
            options={
                'db_table': 'restaurant_app_order',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatisticsOrderItem',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('quantity', models.PositiveIntegerField(default=1)),
                ('phone_number', models.CharField(max_length=10)),
                ('printed', models.BooleanField(default=False)),
                ('printed_quantity', models.IntegerField(default=0)),
            ],
            options={
                'db_table': 'restaurant_app_orderitem',
                'managed': False,
            },
        ),
    ]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\order_statistics\migrations\__init__.py


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\admin.py
from django.contrib import admin
import json
from django.utils.html import format_html
from .models import PickupOrder, Cart, CartItem


class CartItemInline(admin.TabularInline):
    model = CartItem
    extra = 1

class CartInline(admin.TabularInline):
    model = Cart
    extra = 0

class PickupOrderAdmin(admin.ModelAdmin):
    list_display = ('phone', 'name', 'date_created', 'is_completed', 'status', 'payment_method', 'get_orders_count', 'get_cart_total', 'get_cart_snapshot_display')
    list_filter = ('is_completed', 'status', 'payment_method')
    search_fields = ('phone', 'name', 'status', 'payment_method')
    readonly_fields = ('phone', 'name', 'total_amount', 'status', 'date_created', 'date_updated', 'previous_orders_total_display', 'get_cart_snapshot_display', 'payment_method')

    def get_cart_snapshot_display(self, obj):
        if obj.cart_snapshot:
            cart_snapshot = json.loads(obj.cart_snapshot)
            # Формируем список строк с информацией о каждом товаре
            snapshot_lines = [f"{item['product_name']} - {item['total']}₪" for item in cart_snapshot]
            # Объединяем строки в одну строку, разделяя их переносами строки
            formatted_snapshot = "\n".join(snapshot_lines)
            return formatted_snapshot
        return 'No snapshot'
    get_cart_snapshot_display.short_description = 'Cart Snapshot'

    def get_cart_items_display(self, obj):
        items = []
        carts = obj.carts.all()
        for cart in carts:
            for cart_item in cart.cart_items.all():
                product_price = cart_item.product.product_price
                total_price_for_item = product_price * cart_item.quantity
                items.append(f"{cart_item.product} ({cart_item.quantity}) - {total_price_for_item}₪")
        return "\n".join(items)
    get_cart_items_display.short_description = 'Cart Items'

    def previous_orders_total_display(self, obj):
        return f"{obj.previous_orders_total():,.2f}"
    previous_orders_total_display.short_description = "Сумма предыдущих заказов"

    def get_cart_total(self, obj):
        total = 0
        carts = obj.carts.all()
        for cart in carts:
            for cart_item in cart.cart_items.all():
                product_price = cart_item.product.product_price
                total_price_for_item = product_price * cart_item.quantity
                total += total_price_for_item
        return total
    get_cart_total.short_description = 'Total'

    def get_orders_count(self, obj):
        return PickupOrder.objects.filter(phone=obj.phone).count()
    get_orders_count.short_description = 'Orders Count'

    def payment_method(self, obj):
        return obj.payment_method or "Не указан"
    payment_method.short_description = 'Метод Оплаты'


class CartAdmin(admin.ModelAdmin):
    inlines = [CartItemInline]
    list_display = ('pickup_order', 'created_at', 'total_price')

class CartItemAdmin(admin.ModelAdmin):
    list_display = ('cart', 'product', 'quantity')

admin.site.register(PickupOrder, PickupOrderAdmin)



# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\apps.py
from django.apps import AppConfig


class PickupAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'pickup_app'


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\forms.py
from django import forms

from .models import PickupOrder
from restaurant_app.models.orders import OrderItem

class PickupForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        super(PickupForm, self).__init__(*args, **kwargs)
        self.fields['name'].required = False
        
        # Устанавливаем стили для полей
        for field in self.fields.values():
            field.widget.attrs['class'] = 'form-control form-control-lg'
            field.widget.attrs['style'] = 'width: 300px;'
        
        # Дополнительные стили для конкретных полей
        self.fields['phone'].widget.attrs['style'] += 'width: 300px;'
        self.fields['name'].widget.attrs['style'] += 'width: 300px;'

    class Meta:
        model = PickupOrder
        fields = ['phone', 'name']
        labels = {
            'phone': 'Номер телефона:',
            'name': 'Имя:',
        }

class OrderItemForm(forms.ModelForm):
    class Meta:
        model = OrderItem
        fields = ['product', 'quantity', 'phone_number']


class ProductQuantityForm(forms.Form):
    quantity = forms.IntegerField(min_value=1, max_value=10000, initial=1, widget=forms.NumberInput(attrs={
        'class': 'form-control',
        'style': 'width: 100px; display: inline-block;'
    }))

class SearchForm(forms.Form):
    query = forms.CharField(max_length=100, required=False, widget=forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'Поиск'}))

# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\models.py
from django.db import models
from django.utils import timezone
from django.db.models import Sum

from restaurant_app.models.product import Product


class PickupOrder(models.Model):
    phone = models.CharField(max_length=20)
    name = models.CharField(max_length=20)
    date_created = models.DateTimeField(auto_now_add=True, editable=False)
    date_updated = models.DateTimeField(auto_now=True, editable=False)
    is_completed = models.BooleanField(default=False)
    total_amount = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    payment_method = models.CharField(max_length=20, blank=True, null=True)
    cart_snapshot = models.TextField(blank=True, null=True)
    
    NEW = 'new'
    PROCESSING = 'processing'
    COMPLETED = 'completed'
    CANCELED = 'canceled'

    STATUS_CHOICES = [
        (NEW, 'New'),
        (PROCESSING, 'Processing'),
        (COMPLETED, 'Completed'),
        (CANCELED, 'Canceled'),
    ]

    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default=NEW)
    created_at = models.DateTimeField(auto_now_add=True, null=True)

    def __str__(self):
        return f"{self.phone} ({self.name})"
    
    def previous_orders_total(self):
        total = PickupOrder.objects.filter(phone=self.phone, date_created__lt=self.date_created).aggregate(Sum('total_amount'))['total_amount__sum'] or 0
        return total

class Cart(models.Model):
    pickup_order = models.ForeignKey(PickupOrder, on_delete=models.CASCADE, related_name='carts')
    created_at = models.DateTimeField(auto_now_add=True, null=True)
    total_price = models.DecimalField(max_digits=8, decimal_places=2, default=0)

    def get_total(self):
        if not self.pk:  # check if the object has been saved to the database
            return 0
        else:
            return sum([item.quantity * item.product.product_price for item in self.cart_items.all()])

    def save(self, *args, **kwargs):
        self.total_price = self.get_total()
        super().save(*args, **kwargs)

    def __str__(self):
        return f"Cart ({self.pk}) for {self.pickup_order.phone}"

class OrderItem(models.Model):
    order = models.ForeignKey(PickupOrder, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveIntegerField(default=1)

class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name="cart_items")
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveIntegerField(default=1)
    printed_quantity = models.PositiveIntegerField(default=0)  # добавлено это поле

    def __str__(self):
        return f"{self.quantity} x {self.product.product_name_rus}"




# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\tests.py
from django.test import TestCase

# Create your tests here.


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\urls.py
from django.urls import path


from pickup_app.pickup_views.pickup_menu_view import pickup_menu_view
from pickup_app.pickup_views.pickup_create_view import pickup_create_view
from pickup_app.pickup_views.pdf_template_view import pickup_pdf_template_view
from pickup_app.pickup_views.pickup_pdf_views import pickup_generate_pdf_view
from pickup_app.pickup_views.pickup_search_view import pickup_search_products_view
from pickup_app.pickup_views.pickup_kitchen_template_view import pickup_kitchen_view, print_kitchen

from pickup_app.pickup_views.pickup_cart_view import (
    pickup_cart_view, 
    pickup_add_to_cart_view, 
    pickup_remove_product_view,
    pickup_increase_product_view,
    pickup_decrease_product_view,
    pickup_total_price_view,
    pickup_empty_cart_view
                                          
)


app_name = 'pickup_app'

urlpatterns = [
    path('', pickup_create_view, name='pickup_create'),
    path('pickup_search/<str:phone_number>/', pickup_search_products_view, name='pickup_search_products'),

    path('pickup_empty_cart/<str:phone_number>/', pickup_empty_cart_view, name='pickup_empty_cart'),

    path('pickup_cart/<str:phone_number>/<str:category>/', pickup_cart_view, name='pickup_cart'),
    path('pickup_menu/<str:phone_number>/<str:category>/', pickup_menu_view, name='pickup_menu'),
    path('pickup_total_price/<str:phone_number>/', pickup_total_price_view, name='pickup_total_price'),
    path('pickup_add_to_cart/<str:phone_number>/<int:product_id>/<str:category>/', pickup_add_to_cart_view, name='pickup_add_to_cart'),

    path('pickup_kitchen_template/<str:phone_number>/<int:order_id>/', pickup_kitchen_view, name='pickup_kitchen_template'),

    path('print_kitchen/', print_kitchen, name='print_kitchen'),

    path('pickup_generate_pdf/<str:phone_number>/<int:order_id>/', pickup_generate_pdf_view, name='pickup_generate_pdf'),

    path('pickup_pdf_template/<str:phone_number>/<int:order_id>/', pickup_pdf_template_view, name='pickup_pdf_template'),

    path('pickup_remove_product/<str:phone_number>/<int:product_id>/', pickup_remove_product_view, name='pickup_remove_product'), 
    path('pickup_increase_product/<str:phone_number>/<int:product_id>/', pickup_increase_product_view, name='pickup_increase_product'),
    path('pickup_decrease_product/<str:phone_number>/<int:product_id>/', pickup_decrease_product_view, name='pickup_decrease_product'),
] 


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\__init__.py


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\migrations\0001_initial.py
# Generated by Django 4.1.7 on 2023-03-21 08:17

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('restaurant_app', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Cart',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, null=True)),
                ('total_price', models.DecimalField(decimal_places=2, default=0, max_digits=8)),
            ],
        ),
        migrations.CreateModel(
            name='PickupOrder',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('phone', models.CharField(max_length=20)),
                ('name', models.CharField(max_length=20)),
                ('date_created', models.DateTimeField(auto_now_add=True)),
                ('date_updated', models.DateTimeField(auto_now=True)),
                ('is_completed', models.BooleanField(default=False)),
                ('status', models.CharField(choices=[('new', 'New'), ('processing', 'Processing'), ('completed', 'Completed'), ('canceled', 'Canceled')], default='new', max_length=20)),
                ('created_at', models.DateTimeField(auto_now_add=True, null=True)),
            ],
        ),
        migrations.CreateModel(
            name='OrderItem',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('quantity', models.PositiveIntegerField(default=1)),
                ('order', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='pickup_app.pickuporder')),
                ('product', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='restaurant_app.product')),
            ],
        ),
        migrations.CreateModel(
            name='CartItem',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('quantity', models.PositiveIntegerField(default=1)),
                ('cart', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='cart_items', to='pickup_app.cart')),
                ('pickup_order', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='cart_items', to='pickup_app.pickuporder')),
                ('product', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='restaurant_app.product')),
            ],
        ),
        migrations.AddField(
            model_name='cart',
            name='pickup_order',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='carts', to='pickup_app.pickuporder'),
        ),
    ]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\migrations\0002_remove_cartitem_pickup_order.py
# Generated by Django 4.1.7 on 2023-03-21 08:37

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('pickup_app', '0001_initial'),
    ]

    operations = [
        migrations.RemoveField(
            model_name='cartitem',
            name='pickup_order',
        ),
    ]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\migrations\0003_cartitem_printed_quantity.py
# Generated by Django 4.2.1 on 2023-07-20 08:06

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('pickup_app', '0002_remove_cartitem_pickup_order'),
    ]

    operations = [
        migrations.AddField(
            model_name='cartitem',
            name='printed_quantity',
            field=models.PositiveIntegerField(default=0),
        ),
    ]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\migrations\0004_pickuporder_total_amount.py
# Generated by Django 4.2.1 on 2023-10-03 19:47

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('pickup_app', '0003_cartitem_printed_quantity'),
    ]

    operations = [
        migrations.AddField(
            model_name='pickuporder',
            name='total_amount',
            field=models.DecimalField(blank=True, decimal_places=2, max_digits=10, null=True),
        ),
    ]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\migrations\0005_pickuporder_payment_method.py
# Generated by Django 4.2.1 on 2023-11-08 17:12

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('pickup_app', '0004_pickuporder_total_amount'),
    ]

    operations = [
        migrations.AddField(
            model_name='pickuporder',
            name='payment_method',
            field=models.CharField(blank=True, max_length=20, null=True),
        ),
    ]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\migrations\0006_pickuporder_cart_snapshot.py
# Generated by Django 4.2.1 on 2023-11-08 17:25

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('pickup_app', '0005_pickuporder_payment_method'),
    ]

    operations = [
        migrations.AddField(
            model_name='pickuporder',
            name='cart_snapshot',
            field=models.TextField(blank=True, null=True),
        ),
    ]


# End of file

# File: c:\Users\p4ul7\OneDrive\מסמכים\Mimino\pickup_app\migrations\__init__.py


# End of file

